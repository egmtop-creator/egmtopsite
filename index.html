<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Mini 3D Shooter (Raycast) — AK47 + Deagle + Wheel</title>
<style>
  body { margin:0; overflow:hidden; background:#000; color:#fff; font-family:Arial; }
  #ui { position:fixed; top:10px; left:10px; z-index:10; }
  #hint { position:fixed; bottom:10px; left:10px; opacity:.8; z-index:10; max-width: 92vw; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="ui">
  HP: <span id="hp">100</span> |
  Score: <span id="score">0</span> |
  Weapon: <span id="wname">AK-47</span> |
  Ammo: <span id="ammo">30</span>/<span id="reserve">120</span>
  <span id="status"></span>
</div>
<div id="hint">Click to lock mouse • W/S move • A/D strafe • LMB shoot • MouseWheel switch • R reload</div>
<canvas id="c"></canvas>

<script>
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize); resize();

const elHP = document.getElementById("hp");
const elScore = document.getElementById("score");
const elAmmo = document.getElementById("ammo");
const elReserve = document.getElementById("reserve");
const elStatus = document.getElementById("status");
const elWname = document.getElementById("wname");

let keys = {};
addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  keys[k] = true;

  if(k === "r") reload();
  if(k === "1") switchWeaponByKey("ak");
  if(k === "2") switchWeaponByKey("deagle");
});
addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// Pointer Lock (mouse look)
canvas.addEventListener("click", () => canvas.requestPointerLock());
document.addEventListener("pointerlockchange", () => {
  if(document.pointerLockElement === canvas) elStatus.textContent = " (Mouse: ON)";
  else elStatus.textContent = " (Mouse: OFF)";
});

// Mouse (shoot + look)
let mouseDown = false;
let shootPressedEdge = false; // для Deagle (одиночные)
addEventListener("mousedown", (e)=> {
  if(e.button===0){
    mouseDown = true;
    shootPressedEdge = true;
  }
});
addEventListener("mouseup", (e)=> { if(e.button===0) mouseDown = false; });

document.addEventListener("mousemove", (e)=>{
  if(document.pointerLockElement !== canvas) return;
  const sens = 0.0022;
  player.a += e.movementX * sens;
});

// Mouse wheel weapon switch
addEventListener("wheel", (e)=>{
  // чтобы страница не скроллилась
  e.preventDefault();
  if(e.deltaY > 0) switchWeaponByIndex((weaponIndex + 1) % weaponOrder.length);
  else switchWeaponByIndex((weaponIndex - 1 + weaponOrder.length) % weaponOrder.length);
}, { passive:false });

// World map
const mapW = 16, mapH = 16;
const map = [
  "################",
  "#......#.......#",
  "#......#.......#",
  "#......#..##...#",
  "#..........#...#",
  "#..####....#...#",
  "#..#..#........#",
  "#..#..#....##..#",
  "#..#..#....##..#",
  "#..#..........##",
  "#..#...........#",
  "#..####..#.....#",
  "#........#.....#",
  "#........#.....#",
  "#..............#",
  "################",
];

function isWall(x,y){
  const mx = Math.floor(x), my = Math.floor(y);
  if(mx<0||my<0||mx>=mapW||my>=mapH) return true;
  return map[my][mx] === "#";
}

const player = {
  x: 2.5, y: 2.5,
  a: 0,
  fov: Math.PI/3,
  hp: 100
};

let score = 0;
let muzzle = 0;

function normalizeAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

// Raycasting
function castRay(angle, maxDist){
  const sin = Math.sin(angle), cos = Math.cos(angle);
  let dist = 0;
  const step = 0.02;
  while(dist < maxDist){
    const x = player.x + cos*dist;
    const y = player.y + sin*dist;
    if(isWall(x,y)) break;
    dist += step;
  }
  return { dist };
}

// Bots
const bots = [];
function spawnBot(){
  for(let tries=0; tries<60; tries++){
    const x = 1 + Math.random()*(mapW-2);
    const y = 1 + Math.random()*(mapH-2);
    if(!isWall(x,y) && Math.hypot(x-player.x,y-player.y) > 4){
      bots.push({ x, y, hp: 35, speed: 0.85, alive:true });
      return;
    }
  }
}
setInterval(spawnBot, 2200);

// Weapons (AK авто, Deagle одиночные)
const weapons = {
  ak: {
    key: "ak",
    name: "AK-47",
    magSize: 30,
    ammo: 30,
    reserve: 120,
    fireRate: 12,       // shots/sec
    damage: 12,
    maxRange: 11,
    aimConeDeg: 2.2,
    reloadTime: 1.5,
    reloading: false,
    cooldown: 0,
    auto: true
  },
  deagle: {
    key: "deagle",
    name: "Desert Eagle",
    magSize: 7,
    ammo: 7,
    reserve: 35,
    fireRate: 3.5,      // limit
    damage: 32,
    maxRange: 13,
    aimConeDeg: 1.6,
    reloadTime: 1.35,
    reloading: false,
    cooldown: 0,
    auto: false
  }
};

const weaponOrder = ["ak","deagle"];
let weaponIndex = 0;

function curW(){ return weapons[weaponOrder[weaponIndex]]; }

function setHUD(){
  elHP.textContent = Math.floor(player.hp);
  elScore.textContent = score;
  elWname.textContent = curW().name;
  elAmmo.textContent = curW().ammo;
  elReserve.textContent = curW().reserve;
}
setHUD();

function switchWeaponByIndex(i){
  // отменим перезарядку у всех (минималка)
  for(const k of weaponOrder) weapons[k].reloading = false;
  weaponIndex = i;
  setHUD();
}

function switchWeaponByKey(key){
  const i = weaponOrder.indexOf(key);
  if(i >= 0) switchWeaponByIndex(i);
}

function reload(){
  const w = curW();
  if(w.reloading) return;
  if(w.ammo === w.magSize) return;
  if(w.reserve <= 0) return;

  w.reloading = true;
  elStatus.textContent = " (Reloading...)";

  setTimeout(()=>{
    const need = w.magSize - w.ammo;
    const take = Math.min(need, w.reserve);
    w.ammo += take;
    w.reserve -= take;
    w.reloading = false;
    elStatus.textContent = (document.pointerLockElement === canvas) ? " (Mouse: ON)" : " (Mouse: OFF)";
    setHUD();
  }, w.reloadTime * 1000);
}

function dealDamage(rayA, maxRange, coneRad, damage){
  const wallHit = castRay(rayA, maxRange);

  let bestBot = null;
  let bestDist = Infinity;

  for(const b of bots){
    if(!b.alive) continue;
    const dx = b.x - player.x, dy = b.y - player.y;
    const dist = Math.hypot(dx,dy);
    if(dist > maxRange) continue;

    const ang = Math.atan2(dy,dx);
    const da = Math.abs(normalizeAngle(ang - rayA));

    if(da < coneRad){
      if(wallHit.dist > dist && dist < bestDist){
        bestDist = dist;
        bestBot = b;
      }
    }
  }

  if(bestBot){
    bestBot.hp -= damage;
    if(bestBot.hp <= 0){
      bestBot.alive = false;
      score++;
    }
    return true;
  }
  return false;
}

function shootOnce(){
  const w = curW();
  if(w.reloading) return;
  if(w.cooldown > 0) return;

  if(w.ammo <= 0){
    reload();
    return;
  }

  w.ammo--;
  w.cooldown = 1 / w.fireRate;
  muzzle = 7;

  const rayA = player.a;
  const cone = (w.aimConeDeg * Math.PI/180);

  // чуть-чуть рандом точности (минималка)
  const spread = (Math.random()*2 - 1) * cone * 0.65;
  dealDamage(rayA + spread, w.maxRange, cone, w.damage);

  setHUD();
}

function update(dt){
  // timers
  for(const k of weaponOrder){
    const w = weapons[k];
    if(w.cooldown > 0) w.cooldown = Math.max(0, w.cooldown - dt);
  }
  if(muzzle > 0) muzzle -= 20*dt;

  // movement
  const moveSpeed = 2.7;
  let fwd = 0, str = 0;
  if(keys["w"]) fwd += 1;
  if(keys["s"]) fwd -= 1;
  if(keys["a"]) str -= 1;
  if(keys["d"]) str += 1;

  const ca = Math.cos(player.a), sa = Math.sin(player.a);
  const vx = (ca*fwd - sa*str) * moveSpeed * dt;
  const vy = (sa*fwd + ca*str) * moveSpeed * dt;

  const nx = player.x + vx;
  const ny = player.y + vy;
  if(!isWall(nx, player.y)) player.x = nx;
  if(!isWall(player.x, ny)) player.y = ny;

  // shooting behavior
  const w = curW();
  if(w.auto){
    // AK: держишь ЛКМ — стреляет
    if(mouseDown) shootOnce();
  } else {
    // Deagle: один выстрел на нажатие
    if(shootPressedEdge){
      shootOnce();
      shootPressedEdge = false;
    }
  }

  // bots chase
  for(const b of bots){
    if(!b.alive) continue;
    const dx = player.x - b.x, dy = player.y - b.y;
    const dist = Math.hypot(dx,dy);

    const ang = Math.atan2(dy,dx);
    const bx = Math.cos(ang) * b.speed * dt;
    const by = Math.sin(ang) * b.speed * dt;

    const bnx = b.x + bx, bny = b.y + by;
    if(!isWall(bnx, b.y)) b.x = bnx;
    if(!isWall(b.x, bny)) b.y = bny;

    if(dist < 0.75){
      player.hp -= 20*dt;
      if(player.hp < 0) player.hp = 0;
      setHUD();
      if(player.hp <= 0){
        alert("Game Over! Score: " + score);
        location.reload();
      }
    }
  }

  // cleanup
  for(let i=bots.length-1;i>=0;i--){
    if(bots[i].alive === false && Math.random() < 0.02) bots.splice(i,1);
  }
}

function render(){
  const w = canvas.width, h = canvas.height;

  // sky & floor
  ctx.fillStyle = "#0b0f18";
  ctx.fillRect(0,0,w,h/2);
  ctx.fillStyle = "#101010";
  ctx.fillRect(0,h/2,w,h/2);

  // walls
  const numRays = Math.min(520, w);
  for(let i=0;i<numRays;i++){
    const x = i / numRays;
    const rayA = player.a - player.fov/2 + x*player.fov;

    const hit = castRay(rayA, 20);
    const corrected = hit.dist * Math.cos(rayA - player.a);
    const wallH = Math.min(h, (h * 0.9) / Math.max(0.0001, corrected));
    const top = (h - wallH)/2;

    const shade = Math.max(0, 255 - corrected*35);
    ctx.fillStyle = `rgb(${shade|0},${shade|0},${shade|0})`;
    const colW = w / numRays + 1;
    ctx.fillRect(i*colW, top, colW, wallH);
  }

  // bots sprites
  const visible = [];
  for(const b of bots){
    if(!b.alive) continue;
    const dx = b.x - player.x, dy = b.y - player.y;
    const dist = Math.hypot(dx,dy);
    const ang = Math.atan2(dy,dx);
    const rel = normalizeAngle(ang - player.a);
    if(Math.abs(rel) < player.fov/2 && dist < 20) visible.push({b, dist, rel});
  }
  visible.sort((a,b)=> b.dist - a.dist);

  for(const v of visible){
    const {b, dist, rel} = v;
    const wall = castRay(player.a + rel, 20);
    if(wall.dist < dist) continue;

    const size = (h*0.75) / Math.max(0.001, dist);
    const sx = ((rel + player.fov/2) / player.fov) * w;
    const sy = h/2;

    ctx.fillStyle = "rgb(220,40,40)";
    ctx.fillRect(sx - size/2, sy - size/2, size, size);

    const hpPct = Math.max(0, Math.min(1, b.hp/35));
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(sx - size/2, sy - size/2 - 10, size, 6);
    ctx.fillStyle = "rgb(60,220,60)";
    ctx.fillRect(sx - size/2, sy - size/2 - 10, size*hpPct, 6);
  }

  // crosshair
  ctx.strokeStyle = "white";
  ctx.beginPath();
  ctx.moveTo(w/2 - 10, h/2); ctx.lineTo(w/2 + 10, h/2);
  ctx.moveTo(w/2, h/2 - 10); ctx.lineTo(w/2, h/2 + 10);
  ctx.stroke();

  // muzzle flash
  if(muzzle > 0){
    ctx.fillStyle = "rgba(255,255,255,0.18)";
    ctx.beginPath();
    ctx.arc(w/2, h/2, 45, 0, Math.PI*2);
    ctx.fill();
  }

  // ---- Weapon "viewmodel" (минималка, рисуем внизу)
  drawWeaponOverlay(w, h);
}

function drawWeaponOverlay(w, h){
  const weapon = curW();
  const baseX = w*0.55;
  const baseY = h*0.78;

  // лёгкая "отдача" когда стреляем
  const kick = Math.max(0, muzzle) * 1.2;

  ctx.save();
  ctx.translate(baseX, baseY + kick);

  // тень/фон
  ctx.globalAlpha = 0.25;
  ctx.fillStyle = "#000";
  ctx.fillRect(-30, 10, w*0.45, h*0.25);
  ctx.globalAlpha = 1;

  // рисуем разные формы для AK и Deagle
  if(weapon.key === "ak"){
    // body
    ctx.fillStyle = "#2b2b2b";
    ctx.fillRect(0, 40, 260, 35);        // receiver
    ctx.fillRect(240, 30, 170, 18);      // barrel
    // mag
    ctx.fillStyle = "#1f1f1f";
    ctx.beginPath();
    ctx.moveTo(120, 75);
    ctx.lineTo(150, 75);
    ctx.lineTo(175, 145);
    ctx.lineTo(140, 145);
    ctx.closePath();
    ctx.fill();
    // stock
    ctx.fillStyle = "#232323";
    ctx.fillRect(-70, 45, 70, 25);
    ctx.fillRect(-90, 55, 30, 15);
    // grip
    ctx.fillStyle = "#1f1f1f";
    ctx.beginPath();
    ctx.moveTo(95, 75);
    ctx.lineTo(120, 75);
    ctx.lineTo(110, 120);
    ctx.lineTo(85, 120);
    ctx.closePath();
    ctx.fill();
  } else {
    // Deagle
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(40, 55, 210, 28);     // slide
    ctx.fillRect(220, 60, 120, 14);    // barrel
    // grip
    ctx.fillStyle = "#1f1f1f";
    ctx.beginPath();
    ctx.moveTo(110, 83);
    ctx.lineTo(145, 83);
    ctx.lineTo(155, 145);
    ctx.lineTo(120, 145);
    ctx.closePath();
    ctx.fill();
    // trigger guard
    ctx.strokeStyle = "#1f1f1f";
    ctx.lineWidth = 4;
    ctx.strokeRect(130, 86, 35, 20);
  }

  // weapon label
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  ctx.font = "16px Arial";
  ctx.fillText(weapon.name, 10, 25);

  ctx.restore();
}

let last = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t-last)/1000);
  last = t;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>

</html>

