<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8" />
<title>Mini 3D Shooter — AK + Deagle + Wheel + Anim + Sounds + Ammo Pickups</title>
<style>
  body { margin:0; overflow:hidden; background:#000; color:#fff; font-family:Arial; }
  #ui { position:fixed; top:10px; left:10px; z-index:10; user-select:none; }
  #hint { position:fixed; bottom:10px; left:10px; opacity:.8; z-index:10; max-width: 92vw; user-select:none; }
  canvas { display:block; }
</style>
</head>
<body>
<div id="ui">
  HP: <span id="hp">100</span> |
  Score: <span id="score">0</span> |
  Weapon: <span id="wname">AK-47</span> |
  Ammo: <span id="ammo">30</span>/<span id="reserve">120</span>
  <span id="status"></span>
</div>
<div id="hint">Click to lock mouse • W/S move • A/D strafe • LMB shoot • Wheel switch • R reload • Pick up ammo boxes</div>
<canvas id="c"></canvas>

<script>
/* =======================
   Canvas + UI
======================= */
const canvas = document.getElementById("c");
const ctx = canvas.getContext("2d");
function resize(){ canvas.width = innerWidth; canvas.height = innerHeight; }
addEventListener("resize", resize); resize();

const elHP = document.getElementById("hp");
const elScore = document.getElementById("score");
const elAmmo = document.getElementById("ammo");
const elReserve = document.getElementById("reserve");
const elStatus = document.getElementById("status");
const elWname = document.getElementById("wname");

/* =======================
   Input
======================= */
let keys = {};
addEventListener("keydown", e => {
  const k = e.key.toLowerCase();
  keys[k] = true;
  if(k === "r") reload();
  if(k === "1") switchWeaponByKey("ak");
  if(k === "2") switchWeaponByKey("deagle");
});
addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

// Pointer Lock (mouse look)
canvas.addEventListener("click", () => canvas.requestPointerLock());
document.addEventListener("pointerlockchange", () => {
  elStatus.textContent = (document.pointerLockElement === canvas) ? " (Mouse: ON)" : " (Mouse: OFF)";
});

let mouseDown = false;
let shootPressedEdge = false; // for Deagle single shot
addEventListener("mousedown", (e)=> {
  if(e.button===0){
    mouseDown = true;
    shootPressedEdge = true;
    // audio needs user gesture -> init on first interaction
    initAudio();
  }
});
addEventListener("mouseup", (e)=> { if(e.button===0) mouseDown = false; });

document.addEventListener("mousemove", (e)=>{
  if(document.pointerLockElement !== canvas) return;
  const sens = 0.0022;
  player.a += e.movementX * sens;
});

// Mouse wheel weapon switch
addEventListener("wheel", (e)=>{
  e.preventDefault();
  if(e.deltaY > 0) switchWeaponByIndex((weaponIndex + 1) % weaponOrder.length);
  else switchWeaponByIndex((weaponIndex - 1 + weaponOrder.length) % weaponOrder.length);
}, { passive:false });

/* =======================
   Map
======================= */
const mapW = 16, mapH = 16;
const map = [
  "################",
  "#......#.......#",
  "#......#.......#",
  "#......#..##...#",
  "#..........#...#",
  "#..####....#...#",
  "#..#..#........#",
  "#..#..#....##..#",
  "#..#..#....##..#",
  "#..#..........##",
  "#..#...........#",
  "#..####..#.....#",
  "#........#.....#",
  "#........#.....#",
  "#..............#",
  "################",
];

function isWall(x,y){
  const mx = Math.floor(x), my = Math.floor(y);
  if(mx<0||my<0||mx>=mapW||my>=mapH) return true;
  return map[my][mx] === "#";
}

/* =======================
   Player
======================= */
const player = {
  x: 2.5, y: 2.5,
  a: 0,
  fov: Math.PI/3,
  hp: 100
};

let score = 0;

/* =======================
   Math + Raycast
======================= */
function normalizeAngle(a){
  while(a > Math.PI) a -= Math.PI*2;
  while(a < -Math.PI) a += Math.PI*2;
  return a;
}

function castRay(angle, maxDist){
  const sin = Math.sin(angle), cos = Math.cos(angle);
  let dist = 0;
  const step = 0.02;
  while(dist < maxDist){
    const x = player.x + cos*dist;
    const y = player.y + sin*dist;
    if(isWall(x,y)) break;
    dist += step;
  }
  return { dist };
}

/* =======================
   Bots
======================= */
const bots = [];
function spawnBot(){
  for(let tries=0; tries<70; tries++){
    const x = 1 + Math.random()*(mapW-2);
    const y = 1 + Math.random()*(mapH-2);
    if(!isWall(x,y) && Math.hypot(x-player.x,y-player.y) > 4){
      bots.push({ x, y, hp: 35, speed: 0.85, alive:true });
      return;
    }
  }
}
setInterval(spawnBot, 2200);

/* =======================
   Ammo Pickups
======================= */
const pickups = []; // {x,y,type,amount}
function spawnPickup(){
  for(let tries=0; tries<80; tries++){
    const x = 1 + Math.random()*(mapW-2);
    const y = 1 + Math.random()*(mapH-2);
    if(isWall(x,y)) continue;
    // avoid player spawn area & overlap
    if(Math.hypot(x-player.x, y-player.y) < 3.5) continue;
    let ok = true;
    for(const p of pickups){
      if(Math.hypot(p.x-x, p.y-y) < 1.2) { ok=false; break; }
    }
    if(!ok) continue;

    const type = (Math.random() < 0.65) ? "ak" : "deagle";
    const amount = (type === "ak") ? (30 + Math.floor(Math.random()*31)) : (7 + Math.floor(Math.random()*9)); // 30-60 or 7-15
    pickups.push({ x, y, type, amount });
    return;
  }
}
setInterval(()=> {
  if(pickups.length < 6) spawnPickup();
}, 1800);

/* =======================
   Weapons (AK auto, Deagle single)
======================= */
const weapons = {
  ak: {
    key: "ak",
    name: "AK-47",
    magSize: 30,
    ammo: 30,
    reserve: 120,
    fireRate: 12,
    damage: 12,
    maxRange: 11,
    aimConeDeg: 2.2,
    reloadTime: 1.5,
    reloading: false,
    cooldown: 0,
    auto: true
  },
  deagle: {
    key: "deagle",
    name: "Desert Eagle",
    magSize: 7,
    ammo: 7,
    reserve: 35,
    fireRate: 3.5,
    damage: 32,
    maxRange: 13,
    aimConeDeg: 1.6,
    reloadTime: 1.35,
    reloading: false,
    cooldown: 0,
    auto: false
  }
};

const weaponOrder = ["ak","deagle"];
let weaponIndex = 0;
function curW(){ return weapons[weaponOrder[weaponIndex]]; }

function setHUD(){
  elHP.textContent = Math.floor(player.hp);
  elScore.textContent = score;
  elWname.textContent = curW().name;
  elAmmo.textContent = curW().ammo;
  elReserve.textContent = curW().reserve;
}
setHUD();

function switchWeaponByIndex(i){
  // cancel reloads (minimal)
  for(const k of weaponOrder) weapons[k].reloading = false;
  weaponIndex = i;
  setHUD();
}
function switchWeaponByKey(key){
  const i = weaponOrder.indexOf(key);
  if(i >= 0) switchWeaponByIndex(i);
}

/* =======================
   Animations: recoil, screen shake, reload motion
======================= */
let muzzle = 0;         // flash intensity
let recoil = 0;         // weapon kick
let shake = 0;          // screen shake
let reloadAnim = 0;     // 0..1 (weapon down/up)
let reloadDir = 0;      // -1 down, +1 up, 0 idle

function kick(amount){
  recoil = Math.min(1, recoil + amount);
  shake = Math.min(1, shake + amount*0.7);
  muzzle = Math.min(10, muzzle + 7);
}

/* =======================
   Audio (WebAudio, no files)
======================= */
let audioCtx = null;
function initAudio(){
  if(audioCtx) return;
  audioCtx = new (window.AudioContext || window.webkitAudioContext)();
}
function beep(freq, dur, type="square", gain=0.06){
  if(!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const o = audioCtx.createOscillator();
  const g = audioCtx.createGain();
  o.type = type;
  o.frequency.setValueAtTime(freq, t0);
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
  o.connect(g).connect(audioCtx.destination);
  o.start(t0);
  o.stop(t0 + dur);
}
function noise(dur=0.06, gain=0.03){
  if(!audioCtx) return;
  const t0 = audioCtx.currentTime;
  const bufferSize = Math.floor(audioCtx.sampleRate * dur);
  const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
  const data = buffer.getChannelData(0);
  for(let i=0;i<bufferSize;i++) data[i] = (Math.random()*2-1);
  const src = audioCtx.createBufferSource();
  const g = audioCtx.createGain();
  src.buffer = buffer;
  g.gain.setValueAtTime(gain, t0);
  g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
  src.connect(g).connect(audioCtx.destination);
  src.start(t0);
  src.stop(t0 + dur);
}
function sfxShotAK(){ beep(120, 0.04, "square", 0.05); noise(0.03, 0.02); }
function sfxShotDeagle(){ beep(90, 0.06, "sawtooth", 0.06); noise(0.05, 0.025); }
function sfxReload(){ beep(260, 0.05, "triangle", 0.04); beep(180, 0.07, "triangle", 0.03); }
function sfxPickup(){ beep(700, 0.05, "triangle", 0.035); beep(950, 0.04, "triangle", 0.03); }

/* =======================
   Shooting + Reload
======================= */
function dealDamage(rayA, maxRange, coneRad, damage){
  const wallHit = castRay(rayA, maxRange);

  let bestBot = null;
  let bestDist = Infinity;

  for(const b of bots){
    if(!b.alive) continue;
    const dx = b.x - player.x, dy = b.y - player.y;
    const dist = Math.hypot(dx,dy);
    if(dist > maxRange) continue;

    const ang = Math.atan2(dy,dx);
    const da = Math.abs(normalizeAngle(ang - rayA));

    if(da < coneRad){
      if(wallHit.dist > dist && dist < bestDist){
        bestDist = dist;
        bestBot = b;
      }
    }
  }

  if(bestBot){
    bestBot.hp -= damage;
    if(bestBot.hp <= 0){
      bestBot.alive = false;
      score++;
    }
    return true;
  }
  return false;
}

function shootOnce(){
  const w = curW();
  if(w.reloading) return;
  if(w.cooldown > 0) return;

  if(w.ammo <= 0){
    reload();
    return;
  }

  w.ammo--;
  w.cooldown = 1 / w.fireRate;

  // recoil / shake / flash
  kick(w.key === "deagle" ? 0.55 : 0.25);

  // sound
  if(w.key === "ak") sfxShotAK();
  else sfxShotDeagle();

  const cone = (w.aimConeDeg * Math.PI/180);
  const spread = (Math.random()*2 - 1) * cone * 0.75;
  dealDamage(player.a + spread, w.maxRange, cone, w.damage);

  setHUD();
}

function reload(){
  const w = curW();
  if(w.reloading) return;
  if(w.ammo === w.magSize) return;
  if(w.reserve <= 0) return;

  w.reloading = true;
  elStatus.textContent = " (Reloading...)";
  sfxReload();

  // reload animation: weapon goes down then up
  reloadAnim = 0;
  reloadDir = -1;

  setTimeout(()=>{
    const need = w.magSize - w.ammo;
    const take = Math.min(need, w.reserve);
    w.ammo += take;
    w.reserve -= take;
    w.reloading = false;
    elStatus.textContent = (document.pointerLockElement === canvas) ? " (Mouse: ON)" : " (Mouse: OFF)";
    reloadDir = +1;
    setHUD();
  }, w.reloadTime * 1000);
}

/* =======================
   Game Loop: update
======================= */
function update(dt){
  // weapon timers
  for(const k of weaponOrder){
    const w = weapons[k];
    if(w.cooldown > 0) w.cooldown = Math.max(0, w.cooldown - dt);
  }

  // decay recoil/shake/flash
  muzzle = Math.max(0, muzzle - 18*dt);
  recoil = Math.max(0, recoil - 3.5*dt);
  shake  = Math.max(0, shake  - 4.5*dt);

  // reload animation progression (simple)
  if(reloadDir !== 0){
    reloadAnim += reloadDir * 2.6 * dt; // speed
    if(reloadAnim <= 0){ reloadAnim = 0; if(reloadDir < 0) reloadDir = 0; }
    if(reloadAnim >= 1){ reloadAnim = 1; reloadDir = 0; }
  }

  // movement
  const moveSpeed = 2.7;
  let fwd = 0, str = 0;
  if(keys["w"]) fwd += 1;
  if(keys["s"]) fwd -= 1;
  if(keys["a"]) str -= 1;
  if(keys["d"]) str += 1;

  const ca = Math.cos(player.a), sa = Math.sin(player.a);
  const vx = (ca*fwd - sa*str) * moveSpeed * dt;
  const vy = (sa*fwd + ca*str) * moveSpeed * dt;

  const nx = player.x + vx;
  const ny = player.y + vy;
  if(!isWall(nx, player.y)) player.x = nx;
  if(!isWall(player.x, ny)) player.y = ny;

  // shooting behavior
  const w = curW();
  if(w.auto){
    if(mouseDown) shootOnce();
  } else {
    if(shootPressedEdge){
      shootOnce();
      shootPressedEdge = false;
    }
    // if player releases and presses again, edge set in mousedown
  }

  // bots chase + damage
  for(const b of bots){
    if(!b.alive) continue;
    const dx = player.x - b.x, dy = player.y - b.y;
    const dist = Math.hypot(dx,dy);

    const ang = Math.atan2(dy,dx);
    const bx = Math.cos(ang) * b.speed * dt;
    const by = Math.sin(ang) * b.speed * dt;

    const bnx = b.x + bx, bny = b.y + by;
    if(!isWall(bnx, b.y)) b.x = bnx;
    if(!isWall(b.x, bny)) b.y = bny;

    if(dist < 0.75){
      player.hp -= 20*dt;
      if(player.hp < 0) player.hp = 0;
      setHUD();
      if(player.hp <= 0){
        alert("Game Over! Score: " + score);
        location.reload();
      }
    }
  }

  // pickup collection
  for(let i=pickups.length-1;i>=0;i--){
    const p = pickups[i];
    if(Math.hypot(player.x - p.x, player.y - p.y) < 0.65){
      weapons[p.type].reserve += p.amount;
      sfxPickup();
      pickups.splice(i,1);
      setHUD();
    }
  }

  // cleanup dead bots sometimes
  for(let i=bots.length-1;i>=0;i--){
    if(bots[i].alive === false && Math.random() < 0.02) bots.splice(i,1);
  }
}

/* =======================
   Render
======================= */
function render(){
  const w = canvas.width, h = canvas.height;

  // screen shake offset
  const sx = (Math.random()*2 - 1) * 6 * shake;
  const sy = (Math.random()*2 - 1) * 6 * shake;

  ctx.save();
  ctx.translate(sx, sy);

  // sky & floor
  ctx.fillStyle = "#0b0f18";
  ctx.fillRect(-10,-10,w+20,h/2+20);
  ctx.fillStyle = "#101010";
  ctx.fillRect(-10,h/2-10,w+20,h/2+20);

  // walls
  const numRays = Math.min(520, w);
  for(let i=0;i<numRays;i++){
    const x = i / numRays;
    const rayA = player.a - player.fov/2 + x*player.fov;

    const hit = castRay(rayA, 20);
    const corrected = hit.dist * Math.cos(rayA - player.a);
    const wallH = Math.min(h, (h * 0.9) / Math.max(0.0001, corrected));
    const top = (h - wallH)/2;

    const shade = Math.max(0, 255 - corrected*35);
    ctx.fillStyle = `rgb(${shade|0},${shade|0},${shade|0})`;
    const colW = w / numRays + 1;
    ctx.fillRect(i*colW, top, colW, wallH);
  }

  // bots sprites
  const visibleBots = [];
  for(const b of bots){
    if(!b.alive) continue;
    const dx = b.x - player.x, dy = b.y - player.y;
    const dist = Math.hypot(dx,dy);
    const ang = Math.atan2(dy,dx);
    const rel = normalizeAngle(ang - player.a);
    if(Math.abs(rel) < player.fov/2 && dist < 20) visibleBots.push({b, dist, rel});
  }
  visibleBots.sort((a,b)=> b.dist - a.dist);

  for(const v of visibleBots){
    const {b, dist, rel} = v;
    const wall = castRay(player.a + rel, 20);
    if(wall.dist < dist) continue;

    const size = (h*0.75) / Math.max(0.001, dist);
    const px = ((rel + player.fov/2) / player.fov) * w;
    const py = h/2;

    ctx.fillStyle = "rgb(220,40,40)";
    ctx.fillRect(px - size/2, py - size/2, size, size);

    const hpPct = Math.max(0, Math.min(1, b.hp/35));
    ctx.fillStyle = "rgba(0,0,0,0.6)";
    ctx.fillRect(px - size/2, py - size/2 - 10, size, 6);
    ctx.fillStyle = "rgb(60,220,60)";
    ctx.fillRect(px - size/2, py - size/2 - 10, size*hpPct, 6);
  }

  // pickups sprites (ammo boxes)
  const visiblePickups = [];
  for(const p of pickups){
    const dx = p.x - player.x, dy = p.y - player.y;
    const dist = Math.hypot(dx,dy);
    const ang = Math.atan2(dy,dx);
    const rel = normalizeAngle(ang - player.a);
    if(Math.abs(rel) < player.fov/2 && dist < 18) visiblePickups.push({p, dist, rel});
  }
  visiblePickups.sort((a,b)=> b.dist - a.dist);

  for(const v of visiblePickups){
    const {p, dist, rel} = v;
    const wall = castRay(player.a + rel, 20);
    if(wall.dist < dist) continue;

    const size = (h*0.35) / Math.max(0.001, dist);
    const px = ((rel + player.fov/2) / player.fov) * w;
    const py = h/2 + size*0.9;

    ctx.fillStyle = (p.type === "ak") ? "rgb(40,180,255)" : "rgb(255,200,60)";
    ctx.fillRect(px - size/2, py - size/2, size, size);

    ctx.fillStyle = "rgba(0,0,0,0.5)";
    ctx.fillRect(px - size/2, py - size/2, size, size*0.25);
  }

  // crosshair
  ctx.strokeStyle = "white";
  ctx.beginPath();
  ctx.moveTo(w/2 - 10, h/2); ctx.lineTo(w/2 + 10, h/2);
  ctx.moveTo(w/2, h/2 - 10); ctx.lineTo(w/2, h/2 + 10);
  ctx.stroke();

  // muzzle flash overlay
  if(muzzle > 0){
    ctx.fillStyle = `rgba(255,255,255,${0.10 + 0.02*muzzle})`;
    ctx.beginPath();
    ctx.arc(w/2, h/2, 45 + muzzle*2.2, 0, Math.PI*2);
    ctx.fill();
  }

  ctx.restore();

  // weapon overlay on top (no shake transform)
  drawWeaponOverlay(w, h);
}

function drawWeaponOverlay(w, h){
  const weapon = curW();
  const baseX = w*0.55;
  const baseY = h*0.78;

  // recoil kick + reload animation (weapon goes down)
  const kickY = recoil * 18;
  const reloadY = reloadAnim * 80; // down
  const bob = Math.sin(performance.now()*0.006) * 2;

  ctx.save();
  ctx.translate(baseX, baseY + kickY + reloadY + bob);

  // shadow plate
  ctx.globalAlpha = 0.22;
  ctx.fillStyle = "#000";
  ctx.fillRect(-30, 10, w*0.45, h*0.25);
  ctx.globalAlpha = 1;

  if(weapon.key === "ak"){
    ctx.fillStyle = "#2b2b2b";
    ctx.fillRect(0, 40, 260, 35);        // receiver
    ctx.fillRect(240, 30, 170, 18);      // barrel
    ctx.fillStyle = "#1f1f1f";
    ctx.beginPath(); // mag
    ctx.moveTo(120, 75); ctx.lineTo(150, 75); ctx.lineTo(175, 145); ctx.lineTo(140, 145);
    ctx.closePath(); ctx.fill();
    ctx.fillStyle = "#232323";           // stock
    ctx.fillRect(-70, 45, 70, 25);
    ctx.fillRect(-90, 55, 30, 15);
    ctx.fillStyle = "#1f1f1f";           // grip
    ctx.beginPath();
    ctx.moveTo(95, 75); ctx.lineTo(120, 75); ctx.lineTo(110, 120); ctx.lineTo(85, 120);
    ctx.closePath(); ctx.fill();
  } else {
    ctx.fillStyle = "#2a2a2a";
    ctx.fillRect(40, 55, 210, 28);     // slide
    ctx.fillRect(220, 60, 120, 14);    // barrel
    ctx.fillStyle = "#1f1f1f";         // grip
    ctx.beginPath();
    ctx.moveTo(110, 83); ctx.lineTo(145, 83); ctx.lineTo(155, 145); ctx.lineTo(120, 145);
    ctx.closePath(); ctx.fill();
    ctx.strokeStyle = "#1f1f1f";       // trigger guard
    ctx.lineWidth = 4;
    ctx.strokeRect(130, 86, 35, 20);
  }

  // label
  ctx.fillStyle = "rgba(255,255,255,0.75)";
  ctx.font = "16px Arial";
  ctx.fillText(weapon.name, 10, 25);

  ctx.restore();
}

/* =======================
   Main loop
======================= */
let last = performance.now();
function loop(t){
  const dt = Math.min(0.033, (t-last)/1000);
  last = t;
  update(dt);
  render();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);
</script>
</body>
</html>
